<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sermon Search - Live Results</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .search-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .search-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 6px;
            margin-bottom: 10px;
        }
        
        .search-button {
            background: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
        }
        
        .search-button:hover {
            background: #0056b3;
        }
        
        .search-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .progress-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: none;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .progress-text {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .batch-info {
            font-size: 14px;
            color: #666;
        }
        
        .results-split {
            display: flex;
            gap: 20px;
            min-height: 500px;
        }
        
        .results-column {
            flex: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
            display: none;
        }
        
        .results-header {
            padding: 15px 20px;
            font-weight: bold;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .keyword-header {
            background: #28a745;
            color: white;
        }
        
        .semantic-header {
            background: #17a2b8;
            color: white;
        }
        
        .live-indicator {
            font-size: 12px;
            padding: 4px 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 12px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .results-content {
            max-height: 600px;
            overflow-y: auto;
        }
        
        .result-item {
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            transition: all 0.3s ease;
        }
        
        .result-item:hover {
            background-color: #f8f9fa;
        }
        
        .result-item.new {
            animation: slideIn 0.5s ease-out;
            background-color: #fff3cd;
        }
        
        .result-item.updated {
            animation: highlight 1s ease-out;
        }
        
        @keyframes slideIn {
            0% { 
                transform: translateX(20px);
                opacity: 0;
            }
            100% { 
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes highlight {
            0% { background-color: #d4edda; }
            100% { background-color: white; }
        }
        
        .result-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .result-score {
            font-weight: bold;
            margin-right: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .keyword-score {
            background: #28a745;
            color: white;
        }
        
        .semantic-score {
            background: #17a2b8;
            color: white;
        }
        
        .result-title {
            color: #007bff;
            font-weight: bold;
            flex-grow: 1;
        }
        
        .result-date {
            color: #666;
            font-size: 14px;
        }
        
        .result-text {
            margin: 10px 0;
            line-height: 1.5;
            color: #333;
        }
        
        .result-meta {
            font-size: 12px;
            color: #666;
        }
        
        .status-messages {
            background: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: none;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .status-message {
            padding: 3px 0;
            font-family: monospace;
            font-size: 12px;
        }
        
        .no-results {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            background: rgba(255,255,255,0.1);
            padding: 8px 20px;
            font-size: 12px;
            color: rgba(255,255,255,0.9);
        }
        
        .final-stats {
            background: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: none;
            text-align: center;
        }
        
        .empty-column {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-style: italic;
        }
    </style>
</head>
<body>
    <h1>üîç Sermon Search - Live Results</h1>
    
    <div class="search-container">
        <input type="text" id="searchInput" class="search-input" placeholder="Enter your search query..." />
        <button id="searchButton" class="search-button">Search</button>
    </div>
    
    <div id="progressContainer" class="progress-container">
        <div class="progress-text" id="progressText">Initializing search...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="batch-info" id="batchInfo"></div>
    </div>
    
    <div id="statusMessages" class="status-messages">
        <div id="statusLog"></div>
    </div>
    
    <div id="finalStats" class="final-stats">
        <div id="finalStatsContent"></div>
    </div>
    
    <div class="results-split">
        <div id="keywordColumn" class="results-column">
            <div class="results-header keyword-header">
                <span>üéØ Exact Matches</span>
                <span id="keywordCount" class="stats">0 results</span>
            </div>
            <div id="keywordResults" class="results-content">
                <div class="empty-column">No exact matches found</div>
            </div>
        </div>
        
        <div id="semanticColumn" class="results-column">
            <div class="results-header semantic-header">
                <span>üß† Semantic Matches</span>
                <div>
                    <span id="semanticProgress" class="live-indicator" style="display: none;">LIVE</span>
                    <span id="semanticCount" class="stats">0 results</span>
                </div>
            </div>
            <div id="semanticResults" class="results-content">
                <div class="empty-column">Semantic search will appear here...</div>
            </div>
        </div>
    </div>
    
    <script>
        let eventSource = null;
        let keywordResults = [];
        let semanticResults = [];
        let searchInProgress = false;
        
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const progressContainer = document.getElementById('progressContainer');
        const progressText = document.getElementById('progressText');
        const progressFill = document.getElementById('progressFill');
        const batchInfo = document.getElementById('batchInfo');
        const statusMessages = document.getElementById('statusMessages');
        const statusLog = document.getElementById('statusLog');
        const finalStats = document.getElementById('finalStats');
        const finalStatsContent = document.getElementById('finalStatsContent');
        
        const keywordColumn = document.getElementById('keywordColumn');
        const semanticColumn = document.getElementById('semanticColumn');
        const keywordResults_el = document.getElementById('keywordResults');
        const semanticResults_el = document.getElementById('semanticResults');
        const keywordCount = document.getElementById('keywordCount');
        const semanticCount = document.getElementById('semanticCount');
        const semanticProgress = document.getElementById('semanticProgress');
        
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });
        
        searchButton.addEventListener('click', performSearch);
        
        function performSearch() {
            const query = searchInput.value.trim();
            if (!query || searchInProgress) return;
            
            // Reset UI
            keywordResults = [];
            semanticResults = [];
            keywordResults_el.innerHTML = '<div class="empty-column">Searching for exact matches...</div>';
            semanticResults_el.innerHTML = '<div class="empty-column">Preparing semantic search...</div>';
            statusLog.innerHTML = '';
            progressFill.style.width = '0%';
            
            // Show/hide elements
            progressContainer.style.display = 'block';
            statusMessages.style.display = 'block';
            keywordColumn.style.display = 'block';
            semanticColumn.style.display = 'block';
            finalStats.style.display = 'none';
            semanticProgress.style.display = 'none';
            
            keywordCount.textContent = '0 results';
            semanticCount.textContent = '0 results';
            
            searchInProgress = true;
            searchButton.disabled = true;
            searchButton.textContent = 'Searching...';
            
            // Close existing EventSource
            if (eventSource) {
                eventSource.close();
            }
            
            // Start new search with Server-Sent Events
            eventSource = new EventSource(`/search?q=${encodeURIComponent(query)}`);
            
            eventSource.onmessage = function(event = null) {
                const data = JSON.parse(event.data);
                handleSearchUpdate(data);
            };
            
            eventSource.onerror = function(event) {
                console.error('Search error:', event);
                finishSearch();
            };
        }
        
        function handleSearchUpdate(data) {
            switch(data.type) {
                case 'status':
                    addStatusMessage(data.message);
                    break;
                    
                case 'progress':
                    updateProgress(data.progress, data.message, data.batchInfo);
                    break;
                    
                case 'keyword_results':
                    showKeywordResults(data.results);
                    break;
                    
                case 'batch_results':
                    addStatusMessage(`‚ö° Batch ${data.batchNumber}: ${data.count} blocks, ${data.time}ms | Progress: ${data.progress}% | Top: ${data.topScore}%`);
                    updateProgress(data.progress, `Processing batch ${data.batchNumber}...`, `${data.count} blocks processed in ${data.time}ms`);
                    break;
                    
                case 'intermediate_results':
                    updateSemanticResults(data.results, data.progress);
                    break;
                    
                case 'final_results':
                    showFinalResults(data.results, data.stats);
                    finishSearch();
                    break;
                    
                case 'error':
                    addStatusMessage(`‚ùå Error: ${data.message}`);
                    finishSearch();
                    break;
            }
        }
        
        function addStatusMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'status-message';
            messageDiv.textContent = message;
            statusLog.appendChild(messageDiv);
            statusLog.scrollTop = statusLog.scrollHeight;
        }
        
        function updateProgress(progress, message, batchInfoText) {
            progressText.textContent = message;
            progressFill.style.width = progress + '%';
            if (batchInfoText) {
                batchInfo.textContent = batchInfoText;
            }
        }
        
        function showKeywordResults(results) {
            keywordResults = results;
            keywordCount.textContent = `${results.length} results`;
            
            if (results.length === 0) {
                keywordResults_el.innerHTML = '<div class="empty-column">No exact matches found</div>';
                return;
            }
            
            // Show ALL keyword results instead of limiting to 10
            keywordResults_el.innerHTML = results.map((result, index) => `
                <div class="result-item new">
                    <div class="result-header">
                        <span class="result-score keyword-score">EXACT</span>
                        <span class="result-title">${result.sermon_title}</span>
                        <span class="result-date">(${result.sermon_date})</span>
                    </div>
                    ${result.section_number ? `<div class="result-meta">üìñ Section ${result.section_number}</div>` : ''}
                    <div class="result-text">${result.text.length > 200 ? result.text.substring(0, 200) + '...' : result.text}</div>
                    <div class="result-meta">üîó Block ID: ${result.uid}</div>
                </div>
            `).join('');
        }
        
        function updateSemanticResults(results, progress) {
            // Show live indicator
            semanticProgress.style.display = 'inline-block';
            
            // Filter to only semantic results for the right column
            const newSemanticResults = results.filter(r => r.type === 'semantic');
            
            // Find which results are new or updated
            const existingIds = new Set(semanticResults.map(r => r.uid));
            const newIds = new Set();
            const updatedIds = new Set();
            
            newSemanticResults.forEach(result => {
                if (!existingIds.has(result.uid)) {
                    newIds.add(result.uid);
                } else {
                    // Check if score improved
                    const existing = semanticResults.find(r => r.uid === result.uid);
                    if (existing && result.score > existing.score) {
                        updatedIds.add(result.uid);
                    }
                }
            });
            
            semanticResults = newSemanticResults;
            semanticCount.textContent = `${newSemanticResults.length} results (${progress}% complete)`;
            
            if (newSemanticResults.length === 0) {
                semanticResults_el.innerHTML = `<div class="empty-column">Processing... ${progress}% complete</div>`;
                return;
            }
            
            // Sort semantic results by score for display
            const sortedSemanticResults = [...newSemanticResults].sort((a, b) => b.score - a.score);
            
            // Show up to 100 semantic results instead of limiting to 10
            semanticResults_el.innerHTML = sortedSemanticResults.slice(0, 100).map((result, index) => {
                const isNew = newIds.has(result.uid);
                const isUpdated = updatedIds.has(result.uid);
                const animationClass = isNew ? 'new' : (isUpdated ? 'updated' : '');
                
                return `
                    <div class="result-item ${animationClass}">
                        <div class="result-header">
                            <span class="result-score semantic-score">${(result.score * 100).toFixed(1)}%</span>
                            <span class="result-title">${result.sermon_title}</span>
                            <span class="result-date">(${result.sermon_date})</span>
                        </div>
                        ${result.section_number ? `<div class="result-meta">üìñ Section ${result.section_number}</div>` : ''}
                        <div class="result-text">${result.text.length > 200 ? result.text.substring(0, 200) + '...' : result.text}</div>
                        <div class="result-meta">üîó Block ID: ${result.uid}</div>
                    </div>
                `;
            }).join('');
        }
        
        function showFinalResults(results, stats) {
            console.log('Received final results:', results.length, 'total results');
            console.log('First 10 results types:', results.slice(0, 10).map(r => ({ type: r.type, score: r.score })));
            console.log('Stats from server:', stats);
            
            // Hide live indicator
            semanticProgress.style.display = 'none';
            
            // Update final counts based on server stats (more reliable)
            const serverKeywordCount = stats.keyword || 0;
            const serverSemanticCount = stats.semantic || 0;
            
            // Filter results for display - handle hybrid results properly
            const finalKeyword = results.filter(r => r.type === 'keyword');
            // For semantic display, show hybrid results that have semantic components
            const finalSemantic = results.filter(r => 
                r.type === 'semantic' || 
                (r.type === 'hybrid' && r.components && r.components.semantic > 0)
            );
            
            console.log('Client-side filtered results:', {
                totalReceived: results.length,
                keywordFiltered: finalKeyword.length,
                semanticFiltered: finalSemantic.length,
                hybridResults: results.filter(r => r.type === 'hybrid').length,
                serverKeywordCount,
                serverSemanticCount
            });
            
            keywordCount.textContent = `${serverKeywordCount} results`;
            semanticCount.textContent = `${serverSemanticCount} results`;
            
            // Show final stats with coverage info
            finalStats.style.display = 'block';
            const coverageInfo = stats.coverage ? ` | Coverage: ${stats.coverage}` : '';
            const processedInfo = stats.processed ? ` | Processed: ${stats.processed.toLocaleString()}` : '';
            
            finalStatsContent.innerHTML = `
                <strong>üèÜ Search Complete!</strong><br>
                Total: ${stats.total} results | 
                Keyword: ${serverKeywordCount} matches | 
                Semantic: ${serverSemanticCount} matches | 
                Time: ${stats.time}ms${coverageInfo}${processedInfo}
            `;
            
            // Update semantic results with final ranking - show up to 100 results
            if (finalSemantic.length > 0) {
                console.log('Displaying semantic results:', finalSemantic.slice(0, 100));
                const topSemanticResults = finalSemantic.slice(0, 100);
                semanticResults_el.innerHTML = topSemanticResults.map((result, index) => {
                    // For hybrid results, show the semantic component score
                    const displayScore = result.type === 'hybrid' && result.components 
                        ? result.components.raw_semantic || result.components.semantic
                        : result.score;
                    
                    return `
                        <div class="result-item">
                            <div class="result-header">
                                <span class="result-score semantic-score">${(displayScore * 100).toFixed(1)}%</span>
                                <span class="result-title">${result.sermon_title}</span>
                                <span class="result-date">(${result.sermon_date})</span>
                            </div>
                            ${result.section_number ? `<div class="result-meta">üìñ Section ${result.section_number}</div>` : ''}
                            <div class="result-text">${result.text.length > 200 ? result.text.substring(0, 200) + '...' : result.text}</div>
                            <div class="result-meta">
                                üîó Block ID: ${result.uid}
                                ${result.type === 'hybrid' ? ' | üîÑ Hybrid Match' : ''}
                            </div>
                        </div>
                    `;
                }).join('');
            } else if (serverSemanticCount > 0) {
                // Server says there are semantic results but we didn't receive them in this slice
                semanticResults_el.innerHTML = '<div class="empty-column">Semantic results available but not in current view. Server found ' + serverSemanticCount + ' semantic matches.</div>';
            } else {
                console.log('No semantic results to display');
                semanticResults_el.innerHTML = '<div class="empty-column">No semantic matches found</div>';
            }
            
            // Update keyword results - show ALL keyword results instead of limiting to 10
            const keywordForDisplay = results.filter(r => 
                r.type === 'keyword' || 
                (r.type === 'hybrid' && r.components && r.components.keyword > 0)
            );
            
            if (keywordForDisplay.length > 0) {
                // Show ALL keyword results instead of slice(0, 10)
                keywordResults_el.innerHTML = keywordForDisplay.map((result, index) => `
                    <div class="result-item">
                        <div class="result-header">
                            <span class="result-score keyword-score">${result.type === 'hybrid' ? 'HYBRID' : 'EXACT'}</span>
                            <span class="result-title">${result.sermon_title}</span>
                            <span class="result-date">(${result.sermon_date})</span>
                        </div>
                        ${result.section_number ? `<div class="result-meta">üìñ Section ${result.section_number}</div>` : ''}
                        <div class="result-text">${result.text.length > 200 ? result.text.substring(0, 200) + '...' : result.text}</div>
                        <div class="result-meta">
                            üîó Block ID: ${result.uid}
                            ${result.type === 'hybrid' ? ' | üîÑ Hybrid Match' : ''}
                        </div>
                    </div>
                `).join('');
            } else if (serverKeywordCount > 0) {
                keywordResults_el.innerHTML = '<div class="empty-column">Keyword results available but not in current view.</div>';
            }
        }
        
        function finishSearch() {
            searchInProgress = false;
            searchButton.disabled = false;
            searchButton.textContent = 'Search';
            progressContainer.style.display = 'none';
            semanticProgress.style.display = 'none';
            
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
        }
        
        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (eventSource) {
                eventSource.close();
            }
        });
    </script>
</body>
</html>
